#!/usr/bin/env python3
"""
Generates a small Test Script from an existing json Test Specification, mostly used during internal testing and
debugging Process, For the real tests the more extensive Test Scripts are generated by the TST (included logging,
step id, run id,...)
author: Marko Mecina
date: 01.08.2021
edited: Dominik MÃ¶slinger
"""

import datetime
import os
import json
import sys


def run(jfile, outfile):

    if os.path.isfile(jfile):
        data = json.load(open(jfile, 'r'))
    else:
        data = json.loads(jfile)

    date = datetime.datetime.now().strftime('%Y-%m-%d')

    script = ''

    script += '#--------------------------------------------\n'
    script += '# ' + data['_name'] + '\n'
    script += '# ' + data['_description'] + '\n'
    script += '# Specification Version: ' + data['_spec_version'] + '\n'
    script += '# Software Version: ' + data['_iasw_version'] + '\n'
    script += '# Author: UVIE\n# Date: {}\n'.format(date)
    script += '#--------------------------------------------\n\n\n'

    script += '# Precond.\n# {}\n'.format(data['_precon_descr'])
    # script += '{}\n\n\n'.format(data['_precon_code'].strip())  # Add the precondition code

    for step in data['sequences'][0]['steps']:
        comment = '# COMMENT: {}\n'.format(step['_step_comment'].strip()) if step['_step_comment'] != '' else ''

        txt = '# STEP {}\n' \
              '# {}\n' \
              '{}\n' \
              '# VERIFICATION: {}\n{}\n\n'.format(step['_step_number'], step['_description'].strip(),
                                                  step['_command_code'].strip(),
                                                  step['_verification_description'].strip(),
                                                  # step['_verification_code'].strip(), # Add verification code
                                                  comment)

        script += txt

    script += '# Postcond.\n# {}\n'.format(data['_postcon_descr'])
    # script += data['_postcon_code'].strip()  # Add the postcondition code

    if outfile[-1] == '/':  # If path is given not the actual filename
        outfile = outfile + data['_name'] + '-TS' + '-'.join(data['_spec_version']) + '.py'

    with open(outfile, 'w') as fd:
        fd.write(script)


if __name__ == '__main__':
    json_file_path = sys.argv[1]

    if len(sys.argv) > 1:  # If filename is given
        outputfile = sys.argv[2]
    else:  # If no filename is given take the working directory path, filename is used from the json file
        outputfile = os.getcwd() + '/'
        #outputfile = '/'.join(json_file_path[:-len(json_file_path.split('/')[-1])-1]) + '/'  # This would take the json File path

    run(json_file_path, outputfile)
